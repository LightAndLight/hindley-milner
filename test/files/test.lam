data List a = Nil | Cons a (List a)
data Fix f = Fix (f (Fix f))
data Free f a = Wrap (f (Free f a)) | Pure a

fix : forall a. (a -> a) -> a
fix = rec fix' f x = f (fix' f) x in fix'

ite c t e = case c of { true -> t; _ -> e }

filter : forall a. (a -> Bool) -> List a -> List a
filter = let f recurse pred list = case list of { Nil -> Nil; Cons a rest -> ite (pred a) (Cons a (recurse pred rest)) (recurse pred rest) } in fix f

filter' : forall a. (a -> Bool) -> List a -> List a
filter' = rec filter'' pred list = case list of { Nil -> Nil; Cons a rest -> ite (pred a) (Cons a (filter'' pred rest)) (filter'' pred rest) } in filter''

isOne : Int -> Bool
isOne x = case x of { 1 -> true; _ -> false }

test = filter' isOne (Cons 0 (Cons 0 (Cons 0 (Cons 1 (Cons 2 (Cons 1 Nil))))))

sig : forall f a. List a -> a
